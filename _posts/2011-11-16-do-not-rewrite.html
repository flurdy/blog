---
layout: post
title: Do not rewrite
date: '2011-11-16T12:16:00.004Z'
author: flurdy
tags:
- legacy
- code
- agile
- architecture
- systems
modified_time: '2011-11-23T18:52:48.027Z'
blogger_id: tag:blogger.com,1999:blog-4019909.post-4975075462179067859
blogger_orig_url: http://blog.flurdy.com/2011/11/do-not-rewrite.html
---

<b>Just donâ€™t do it</b><br /><br /><b>Instead evolve</b><br /><br />Many (99.99%) of developers continually insist that whichever application they work on needs a rewrite. As in scratch everything, redesign the architecture and technology choices and rewrite every component because the current choice and state is not ideal. I used to feel and say this as well.<br /><br />Any code I have written (and even worse if written by others) which I need to update/maintain will look bad after only 6 months. After 2 years it smells of bad architecture design and logic. After 5 years the code base feels like a mess, totally unmaintainable. <br /><br />This is slightly because technology has moved on, and my skills or rather preferences have evolved.  But it is mostly due to that over time any application has been updated due to bug fixes and new features, and the maintainance might have been handed over to other people several times, with different skill level or understanding of the architecture. This bloats the code structure and exceeds what the original and probably quite tidy structure was intended for.<br /><br />Any further maintenance is more and more costly as it takes longer and/or more people to make any changes to the application. And any innovation is muffled as inspiration is dampened. <br /><br />Many companies makes a good living when other companies outsources the costly maintenance of these systems.<br /><br /><br />I used to feel the need to rewrite in every new assignment but not anymore. My advice now is: <b>Please do not rewrite</b><br /><br /><br />Why are rewrites a bad idea?<br /><br /><br /><b>No value</b><br /><br />If you undertake a rewrite of your core application it will be very costly for your business, with no initial return on investment. Take 6 -12 months of pure losses and in the end the customer (internal or external) has not received any extra value. Most likely they will have less features as scope was reduced, but rarely any new features. Future performance gains and maintainability is a plus but not of value there and then. So it is a huge hit on fragile budgets or even liquidity of smaller companies, with little to no benefit.<br /><br />This is the main reason not to rewrite, the business side gains nothing from it, it is a pure expense. Any reasonable business person would not approve it. And any future relationship will quite likely be very damaged.<br /><br /><br /><b>Never finishing</b><br /><br />Another risk is that the rewrite takes too long and either never really finishes or is cancelled. Making it an expensive task with no value now nor in the future.<br /><br />Also rewrites that span a long time usually suffers from that the decisions made at the beginning start to look outdated and wrong before it is even in production and before any future value is gained.<br /><br /><br /><h3>Evolve</h3><br />However I do not mean you should not evolve your application. Do not keep status quo either. If it is an important core application, you should evolve it, but not perform a total rewrite.<br /><br />Instead do it in smaller steps while adding value and features for the customer. This way your product is cleaner and up to date, but the business side does not take a huge hit. This is also much more predictable and less volatile. Which make is less likely the project will be cancelled or worse for smaller companies which could go bankrupt.<br /><br /><br />How do you go about evolving and not rewriting? This very much depends on your type of application. <br /><br />(If it is a tiny application, go ahead rewrite it. Just make sure the dependant systems are aware of this).<br /><br /><br /><b>Refactor</b><br /><br />On a minor level, continual process of refactoring, with larger refactoring a frequent acceptable task. This should slow down code rot, postponing the need for larger changes a while.<br /><br /><br /><b>Modularisation</b><br /><br />Eventually your application will need a drastic change. If by chance your original design was quite modular or less coupled with other systems you made evolving smoother. If not, try to modularise your current design.<br /><br />By being modular you can still perform rewrites, but on much smaller scale, taking one module at the time. So that it is not a 12 months loss, but perhaps 1 month loss. While normal work on other modules can still continue. Much less likely to kill your project/company.<br /><br /><br /><b>Parallel systems</b><br /><br />Instead of a hard one day switch over from the old system to the new system, instead run two systems in parallel for awhile, the old legacy system and the new clean system.<br /><br /><br /><b>Skinny interface adapter layer</b><br /><br />If modularised or not, a cleaner way to evolve and replace sections of your application is to introduce an adapter layer for your interface, and keeping it skinny.<br /><br />This interface adapter only relays between your system/application and other systems. When other systems only talk via the adapter you are free to change your system without affecting external systems. <br /><br />More importantly you can now split your system into two systems and relay certain calls to the new system instead of the old, without external systems are aware nor affected by this.<br /><br />The adapter layer is not always possible, or people are resistant to introduce yet another layer/system, but it really makes your much more adaptable in changing your own architecture, you can move elements to a new system and roll back without external costs.<br /><br /><br /><b>No logic in adapter layer</b><br /><br />Do not ever put any logic in interface adapter. Otherwise you end up with yet another system to maintain. Unfortunately this happens quite often when bad planning and management leads to shortcuts which adds logic in the adapter layer. And then you have just multiplied your maintenance costs. And believe me that logic is then rarely temporary.<br /><br /><br /><b>ESB</b><br /><br />Do not interpret this adapter layer requirement as a reason for introducing an <a href="http://en.wikipedia.org/wiki/Enterprise_service_bus">ESB</a>. ESB tend to just camouflage the spaghetti integration code, and often introduce above mention unwanted logic. However if you already have an ESB in place it can perform the adapter layer requirement.<br /><br /><br /><b>Legacy system becomes adapter layer</b><br /><br />Another method implementing the adapter layer is to use the existing system to relay calls to the new system instead of handling them themselves. Internally in the existing legacy system you have to do this anyway on each element migrated to the new system, so you can also allow external system to do this. <br /><br />It is however cleaner to have a separate adapter layer. This will be easier to maintain as probably designed on newer technology and platforms. And allows you switch off the legacy system when you can. But also makes so less likely for people to just decide to use the legacy system instead.<br /><br /><br /><b>Topic / feature</b><br /><br />An even better rewrite strategy/evolution than per module is per topic / feature. This is an even smaller grained change and less risky. As part of more agile strategies you can move one feature at the time to the new clean system. <br /><br />With an adapter layer this switching is smooth, but not restricted to an adapter layer. Without the adapter you just have more administration of changing every dependant system for each feature moved.<br /><br /><a href="http://martinfowler.com/bliki/FeatureToggle.html">Feature toggles</a> might be part of this strategy.<br /><br /><br /><br /><b>New feature -> new system<br />Update feature -> new system</b><br /><br />Every new feature request is naturally going to be implemented on the new system. But a good method of choosing which existing features to move is choosing a feature which there is a requirement to modify. Then not touch it on the old system but instead rewrite and update it on the new system. This is then a good carrot/stick way to ensure the migration is performed. And ensures that the company receive some value for each rewrite.<br /><br /><br /><b>Do not update old(legacy) system/application</b><br /><br />Another very important rule is not to update the old legacy system at all when each feature/module is migrated off it.  It is so tempting to make a shortcut and update both system as perhaps you have not introduced an adapter layer or instructed enough external systems to use the new system. This will kill your migration/rewrite.<br /><br />For this step the leadership of your team needs to be firm about and insist on. Do not end up maintaining two systems (or 3 with the adapter layer).<br /><br /><br /><b>Ensure legacy system delegates</b><br /><br />The legacy system will undoubtedly internally refer to the rewritten and migrate module or feature. You need to ensure the legacy system now delegates internally to the new system. This is the only update you should do on the old system. Otherwise again you will need to maintain two systems, and run the risk of the legacy system and the new system executes slightly differently for the same task, leading to people insisting on using the legacy system.<br /><br /><br /><b>Kill the legacy system</b><br /><br />You need to plan and ensure the old system is eventually switched off. Otherwise you will still need to keep people and skills on how to maintain that system. It may be tempting and erroneously to leave some elements behind that should be on the new architecture.<br /><br />There may be some elements not needed on new system or unrelated that is left on the old system.  But probably better to even move these to another new system than keep the old system lying around and increasing the cost of maintaining that small element as well.<br /><br /><br /><b>Kill the adapter layer?</b><br /><br />Once you killed the legacy system, do you want to keep the adapter layer? Keep in mind you might want to move on from the new system when it starts to rot as well. However it may be tidier and less complicated to kill the adapter layer as well. I would kill it and if needed in the future reintroduce it instead.<br /><br /><br /><b>Do not stop half way</b><br /><br />If for some reason the migration to a new system is stopped, either due to reprioritisation, lack of progress etc, then you are stuck with maintaining not 1 but 3 systems. Many companies end up burned by this and is mostly down to not strong enough leadership/management.<br /><br /><br />So my point is to rewrite small topics/features then modules, but never the whole application. This way value is introduced along the way without a budgetary black hole.<br /><br /><br /><b>References</b><br /><br />Many, but some from former colleague <a href="http://www.f12.no">Anders Sveen</a><br /><br /><br/><br /><br/>